# Модуль 1 — Архитектура GPU и коалесцирование памяти

В этом модуле мы изучаем основы архитектуры GPU (SIMT, иерархия памяти, блоки/варпы) и демонстрируем влияние паттернов доступа к памяти на производительность.

## Пример `memory_access.cu`

Программа сравнивает время выполнения двух ядер:

1. **vecAddCoalesced** — потоковая (коалесцированная) загрузка данных;
2. **vecAddStrided** — некоалесцированный доступ с шагом 32 (размер варпа).

### Сборка

Из корня репозитория:

```bash
cd build && cmake --build . -j$(nproc)
```

### Запуск

```bash
./modules/01-architecture/memory_access
```

Ожидаемый вывод (пример):

```text
Vector size: 16777216 elements
Coalesced access time:       1.25 ms
Strided (stride=32) time: 6.80 ms
Strided / Coalesced ratio: 5.44x
```

Коэффициент показывает, насколько дороже некоалесцированный доступ.

## Задания

1. Измените `stride` на 2, 4, 8, 16 и измерьте время.
2. Попробуйте увеличить размер вектора до `1 << 26`.
3. Добавьте использование `cudaOccupancyMaxActiveBlocksPerMultiprocessor` для оценки заполнения. 