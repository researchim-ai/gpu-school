# Модуль 6 — Advanced CUDA Features (Graph API)

CUDA Graph API позволяет *один раз* описать граф операций (копии, ядра, синхронизации) и затем переиспользовать его без накладных расходов на драйверные вызовы.

Преимущества:
- Снижает CPU-overhead для коротких или часто повторяющихся лончей.
- Позволяет планировщику GPU оптимизировать порядок операций.
- Может исполняться в разных потоках CPU.

## Пример `graph_vector_add.cu`

1. Начинаем захват (`cudaStreamBeginCapture`).  
2. Записываем: H2D копии → ядро VectorAdd → D2H копия.  
3. Завершаем захват → получаем объект `cudaGraph_t`.  
4. Инстанцируем (`cudaGraphInstantiate`) и запускаем граф 100 раз.

### Сборка и запуск

```bash
cmake --build build --target graph_vector_add -j$(nproc)
./build/graph_vector_add          # 1М элементов, 100 итераций
./build/graph_vector_add 8388608  # 8М элементов
```

### Теория

| Этап | API | Описание |
|------|-----|----------|
| Захват | `cudaStreamBeginCapture / EndCapture` | Превращает последовательность асинхронных вызовов в узлы графа |
| Инстанциация | `cudaGraphInstantiate` | Подготавливает граф к выполнению (можно кешировать) |
| Запуск | `cudaGraphLaunch` | Мгновенно отправляет весь граф на GPU |

> На Ada/Hopper графы могут исполняться аппаратно на уровне GSP (GPU Scheduling Processor).

## Задания
1. Измерьте разницу между 100 обычными лончами и 100 `cudaGraphLaunch`.  
2. Добавьте второй этап вычисления (например, SAXPY) в тот же граф.  
3. Сериализуйте граф в файл (`cudaGraphSerialize`) и загрузите обратно. 