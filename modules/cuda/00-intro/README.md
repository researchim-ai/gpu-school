# Модуль 0 — Введение / Introduction

Этот модуль проверяет рабочее окружение и демонстрирует базовый запуск ядра CUDA. Мы собираем и запускаем программу **Hello GPU**, выводящую сообщения из потоков на устройстве.

## Требования

- NVIDIA GPU, совместимая с CUDA 11+
- Установленный CUDA Toolkit (рекомендуется последняя LTS-версия)
- CMake ≥ 3.20 и компилятор `gcc` / `clang` с поддержкой C++17

## Сборка

```bash
# В корне репозитория:
mkdir -p build && cd build
cmake .. -DCMAKE_BUILD_TYPE=Release
cmake --build . -j$(nproc)
```

## Запуск

```bash
./modules/00-intro/hello_gpu
```

Ожидаемый вывод:

```text
Hello from GPU thread 0
Hello from GPU thread 1
...
Hello from GPU thread 31
```

Если программа выполнилась успешно и отобразила приветствия от всех потоков — ваше окружение готово к дальнейшей работе!

## Что дальше?

- Изучите исходный код `src/hello_gpu.cu`.
- Измените количество блоков и потоков, пересоберите проект и посмотрите, как изменится вывод.
- Перейдите к Модулю 1, где мы углубимся в архитектуру GPU и модель SIMT.

## Теория

GPU использует модель **SIMT (Single Instruction, Multiple Threads)**. Потоки объединяются в варпы по 32 нити и исполняют одну и ту же инструкцию, но над разными данными.

Ключевые термины:

| Понятие | Описание |
|---------|----------|
| **Grid** | Вся сетка исполнения ядра. Состоит из блоков. |
| **Block** | Группа нитей, которые могут синхронизироваться через `__syncthreads()` и совместно использовать *shared memory*. |
| **Thread** | Индивидуальная нить исполнения внутри блока. |
| **Warp** | Аппаратная группа из 32 нитей, минимальная единица планирования. |
| **Global memory** | Большая, но медленная память (GDDR/HBM). Доступна всем блокам. |
| **Shared memory** | Быстрый on-chip SRAM, общий для нитей блока (≈ 100× быстрее чем глобальная). |

При вызове `hello_kernel<<<1, 32>>>();` создаётся:

```
Grid  = 1 block
Block = 32 threads
Warp  = 1 (т.к. 32 нити)
```

Каждый поток вычисляет свой глобальный индекс и печатает строку. В реальных программах вместо `printf` нити выполняют численные расчёты.

> Памятка: `printf` в ядрах полезен для отладки, но сильно замедляет выполнение и ограничен по объёму вывода. 